# Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.

class Solution:
    def toLowerCase(self, str: str) -> str:
        lowerCase = str.lower()
        return lowerCase

# Write a function that reverses a string. The input string is given as an array of characters char[].

# Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.

class Solution:
    def reverseString(self, s: List[str]) -> None:
        """
        Do not return anything, modify s in-place instead.
        """
        s.reverse()

# Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.

class Solution:
    def reverseWords(self, s: str) -> str:
        reversedWords=[]
        listOfWords= s.split()
        print(listOfWords)
        for word in listOfWords:
            print("This is word", word)
            reversedWords.append(word[::-1])
        
        
        print("This is reversed words", reversedWords)
        return " ".join(reversedWords)

# Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

# Follow up: Could you implement a solution with a linear runtime complexity and without using extra memory?

class Solution:
    def singleNumber(self, nums: List[int]) -> int:
        single_number = []
        for num in nums:
            if num not in single_number:
                single_number.append(num)
            else:
                single_number.remove(num)
        return single_number[0]

# Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).

class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        #sort the array so we know where the biggest numbers are 
        nums.sort()
        print("THIS IS NUMS", nums)
        #return the output of multiplying the two biggest numbers where both are subtracted by 1
        return (nums[-1]-1) * (nums[-2]-1)

# Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A.

# You may return any answer array that satisfies this condition.

class Solution:
    def sortArrayByParity(self, A: List[int]) -> List[int]:
        #create two empty arrays 
        even=[]
        odd=[]
        #iterate through the list of numbers checking if even or odd, appending to appropriate list
        for num in A:
            if (num%2)==0:
                even.append(num)
            else:
                odd.append(num)
        for num in odd:
            even.append(num)
        return even



# The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,

class Solution:
    def fib(self, n: int) -> int:
        if n <= 1 :
            return n 
        return self.fib(n-1) + self.fib(n-2)


# You are given two strings s and t.

# String t is generated by random shuffling string s and then add one more letter at a random position.

# Return the letter that was added to t.

class Solution:
    def findTheDifference(self, s: str, t: str) -> str:
        #use a list comprehension to place the characters of each          string into a list 
        first_string = [char for char in s]
        second_string= [char for char in t]
        print("THIS IS FIRST STRING", first_string)
        print("THIS IS SECOND STRING", second_string)
        #use a for loop to run through the second string checking          if the character is present, if not return it 
        for character in second_string:
            if character not in first_string:
                return character

Given alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).

You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.

Return the reformatted string or return an empty string if it is impossible to reformat the string.

class Solution:
    def reformat(self, s: str) -> str:
        nums=[]
        letters=[]
        emptyString=""
        for ele in s:
            if ele.isdigit():
                nums.append(ele)
            else:
                letters.append(ele)
        print("THIS IS NUMS", nums)
        print("THIS IS LETTERS", letters)
        if len(nums)-len(letters) > 1:
            return emptyString
        result = ''.join(a + c for a, c in zip(nums, letters))
        return result

# Given a string, find the first non-repeating character in it and return its index. If it doesn't exist, return -1.


class Solution:
    def firstUniqChar(self, s: str) -> int:
        for i in range(len(s)):
            character = s[i]
            print("THIS IS CHARACTER", character)
            if s.count(character)==1:
                return i

        return -1

# Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.

class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        #create a dummy node for output
        dummy = ListNode()
        tail = dummy 
        while l1 and l2:
            if l1.val <= l2.val:
                tail.next = l1
                l1 = l1.next 
            else: 
                tail.next = l2
                l2 = l2.next
            # tail is updated regardless
            tail = tail.next 
        #case for empty list
        if l1:
            tail.next = l1
        elif l2:
            tail.next = l2
        return dummy.next